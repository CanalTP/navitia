// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chaos.proto

#ifndef PROTOBUF_chaos_2eproto__INCLUDED
#define PROTOBUF_chaos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gtfs-realtime.pb.h"
// @@protoc_insertion_point(includes)

namespace chaos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_chaos_2eproto();
void protobuf_AssignDesc_chaos_2eproto();
void protobuf_ShutdownFile_chaos_2eproto();

class Category;
class Cause;
class Channel;
class Disruption;
class DisruptionProperty;
class Impact;
class LineSection;
class Message;
class Meta;
class PtObject;
class Severity;
class Tag;
class Wording;

enum PtObject_Type {
  PtObject_Type_network = 1,
  PtObject_Type_stop_area = 2,
  PtObject_Type_line = 3,
  PtObject_Type_line_section = 4,
  PtObject_Type_route = 5,
  PtObject_Type_unkown_type = 6,
  PtObject_Type_stop_point = 7,
  PtObject_Type_trip = 8
};
bool PtObject_Type_IsValid(int value);
const PtObject_Type PtObject_Type_Type_MIN = PtObject_Type_network;
const PtObject_Type PtObject_Type_Type_MAX = PtObject_Type_trip;
const int PtObject_Type_Type_ARRAYSIZE = PtObject_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PtObject_Type_descriptor();
inline const ::std::string& PtObject_Type_Name(PtObject_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PtObject_Type_descriptor(), value);
}
inline bool PtObject_Type_Parse(
    const ::std::string& name, PtObject_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PtObject_Type>(
    PtObject_Type_descriptor(), name, value);
}
enum Channel_Type {
  Channel_Type_web = 1,
  Channel_Type_sms = 2,
  Channel_Type_email = 3,
  Channel_Type_mobile = 4,
  Channel_Type_notification = 5,
  Channel_Type_twitter = 6,
  Channel_Type_facebook = 7,
  Channel_Type_unkown_type = 8,
  Channel_Type_title = 9,
  Channel_Type_beacon = 10
};
bool Channel_Type_IsValid(int value);
const Channel_Type Channel_Type_Type_MIN = Channel_Type_web;
const Channel_Type Channel_Type_Type_MAX = Channel_Type_beacon;
const int Channel_Type_Type_ARRAYSIZE = Channel_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Channel_Type_descriptor();
inline const ::std::string& Channel_Type_Name(Channel_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Channel_Type_descriptor(), value);
}
inline bool Channel_Type_Parse(
    const ::std::string& name, Channel_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Channel_Type>(
    Channel_Type_descriptor(), name, value);
}
// ===================================================================

class Disruption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Disruption) */ {
 public:
  Disruption();
  virtual ~Disruption();

  Disruption(const Disruption& from);

  inline Disruption& operator=(const Disruption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Disruption& default_instance();

  void Swap(Disruption* other);

  // implements Message ----------------------------------------------

  inline Disruption* New() const { return New(NULL); }

  Disruption* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Disruption& from);
  void MergeFrom(const Disruption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Disruption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string reference = 3;
  bool has_reference() const;
  void clear_reference();
  static const int kReferenceFieldNumber = 3;
  const ::std::string& reference() const;
  void set_reference(const ::std::string& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  ::std::string* mutable_reference();
  ::std::string* release_reference();
  void set_allocated_reference(::std::string* reference);

  // optional .transit_realtime.TimeRange publication_period = 4;
  bool has_publication_period() const;
  void clear_publication_period();
  static const int kPublicationPeriodFieldNumber = 4;
  const ::transit_realtime::TimeRange& publication_period() const;
  ::transit_realtime::TimeRange* mutable_publication_period();
  ::transit_realtime::TimeRange* release_publication_period();
  void set_allocated_publication_period(::transit_realtime::TimeRange* publication_period);

  // optional uint64 created_at = 6;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 6;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 7;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 7;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // optional .chaos.Cause cause = 8;
  bool has_cause() const;
  void clear_cause();
  static const int kCauseFieldNumber = 8;
  const ::chaos::Cause& cause() const;
  ::chaos::Cause* mutable_cause();
  ::chaos::Cause* release_cause();
  void set_allocated_cause(::chaos::Cause* cause);

  // repeated .chaos.Impact impacts = 9;
  int impacts_size() const;
  void clear_impacts();
  static const int kImpactsFieldNumber = 9;
  const ::chaos::Impact& impacts(int index) const;
  ::chaos::Impact* mutable_impacts(int index);
  ::chaos::Impact* add_impacts();
  ::google::protobuf::RepeatedPtrField< ::chaos::Impact >*
      mutable_impacts();
  const ::google::protobuf::RepeatedPtrField< ::chaos::Impact >&
      impacts() const;

  // repeated .chaos.Tag tags = 11;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 11;
  const ::chaos::Tag& tags(int index) const;
  ::chaos::Tag* mutable_tags(int index);
  ::chaos::Tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::chaos::Tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::chaos::Tag >&
      tags() const;

  // optional string note = 12;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 12;
  const ::std::string& note() const;
  void set_note(const ::std::string& value);
  void set_note(const char* value);
  void set_note(const char* value, size_t size);
  ::std::string* mutable_note();
  ::std::string* release_note();
  void set_allocated_note(::std::string* note);

  // repeated .chaos.PtObject localization = 13;
  int localization_size() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 13;
  const ::chaos::PtObject& localization(int index) const;
  ::chaos::PtObject* mutable_localization(int index);
  ::chaos::PtObject* add_localization();
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
      mutable_localization();
  const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
      localization() const;

  // optional string contributor = 14;
  bool has_contributor() const;
  void clear_contributor();
  static const int kContributorFieldNumber = 14;
  const ::std::string& contributor() const;
  void set_contributor(const ::std::string& value);
  void set_contributor(const char* value);
  void set_contributor(const char* value, size_t size);
  ::std::string* mutable_contributor();
  ::std::string* release_contributor();
  void set_allocated_contributor(::std::string* contributor);

  // repeated .chaos.DisruptionProperty properties = 15;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 15;
  const ::chaos::DisruptionProperty& properties(int index) const;
  ::chaos::DisruptionProperty* mutable_properties(int index);
  ::chaos::DisruptionProperty* add_properties();
  ::google::protobuf::RepeatedPtrField< ::chaos::DisruptionProperty >*
      mutable_properties();
  const ::google::protobuf::RepeatedPtrField< ::chaos::DisruptionProperty >&
      properties() const;

  // @@protoc_insertion_point(class_scope:chaos.Disruption)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_reference();
  inline void clear_has_reference();
  inline void set_has_publication_period();
  inline void clear_has_publication_period();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_cause();
  inline void clear_has_cause();
  inline void set_has_note();
  inline void clear_has_note();
  inline void set_has_contributor();
  inline void clear_has_contributor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr reference_;
  ::transit_realtime::TimeRange* publication_period_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::chaos::Cause* cause_;
  ::google::protobuf::RepeatedPtrField< ::chaos::Impact > impacts_;
  ::google::protobuf::RepeatedPtrField< ::chaos::Tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr note_;
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject > localization_;
  ::google::protobuf::internal::ArenaStringPtr contributor_;
  ::google::protobuf::RepeatedPtrField< ::chaos::DisruptionProperty > properties_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Disruption* default_instance_;
};
// -------------------------------------------------------------------

class Wording : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Wording) */ {
 public:
  Wording();
  virtual ~Wording();

  Wording(const Wording& from);

  inline Wording& operator=(const Wording& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wording& default_instance();

  void Swap(Wording* other);

  // implements Message ----------------------------------------------

  inline Wording* New() const { return New(NULL); }

  Wording* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Wording& from);
  void MergeFrom(const Wording& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Wording* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:chaos.Wording)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Wording* default_instance_;
};
// -------------------------------------------------------------------

class Category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Category) */ {
 public:
  Category();
  virtual ~Category();

  Category(const Category& from);

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Category& default_instance();

  void Swap(Category* other);

  // implements Message ----------------------------------------------

  inline Category* New() const { return New(NULL); }

  Category* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Category* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 created_at = 3;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 3;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 4;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chaos.Category)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Category* default_instance_;
};
// -------------------------------------------------------------------

class Cause : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Cause) */ {
 public:
  Cause();
  virtual ~Cause();

  Cause(const Cause& from);

  inline Cause& operator=(const Cause& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cause& default_instance();

  void Swap(Cause* other);

  // implements Message ----------------------------------------------

  inline Cause* New() const { return New(NULL); }

  Cause* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cause& from);
  void MergeFrom(const Cause& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Cause* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string wording = 2;
  bool has_wording() const;
  void clear_wording();
  static const int kWordingFieldNumber = 2;
  const ::std::string& wording() const;
  void set_wording(const ::std::string& value);
  void set_wording(const char* value);
  void set_wording(const char* value, size_t size);
  ::std::string* mutable_wording();
  ::std::string* release_wording();
  void set_allocated_wording(::std::string* wording);

  // optional uint64 created_at = 3;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 3;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 4;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // repeated .chaos.Wording wordings = 5;
  int wordings_size() const;
  void clear_wordings();
  static const int kWordingsFieldNumber = 5;
  const ::chaos::Wording& wordings(int index) const;
  ::chaos::Wording* mutable_wordings(int index);
  ::chaos::Wording* add_wordings();
  ::google::protobuf::RepeatedPtrField< ::chaos::Wording >*
      mutable_wordings();
  const ::google::protobuf::RepeatedPtrField< ::chaos::Wording >&
      wordings() const;

  // optional .chaos.Category category = 6;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 6;
  const ::chaos::Category& category() const;
  ::chaos::Category* mutable_category();
  ::chaos::Category* release_category();
  void set_allocated_category(::chaos::Category* category);

  // @@protoc_insertion_point(class_scope:chaos.Cause)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_wording();
  inline void clear_has_wording();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_category();
  inline void clear_has_category();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr wording_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::RepeatedPtrField< ::chaos::Wording > wordings_;
  ::chaos::Category* category_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Cause* default_instance_;
};
// -------------------------------------------------------------------

class Impact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Impact) */ {
 public:
  Impact();
  virtual ~Impact();

  Impact(const Impact& from);

  inline Impact& operator=(const Impact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Impact& default_instance();

  void Swap(Impact* other);

  // implements Message ----------------------------------------------

  inline Impact* New() const { return New(NULL); }

  Impact* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Impact& from);
  void MergeFrom(const Impact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Impact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional uint64 created_at = 2;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 2;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 3;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 3;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // repeated .transit_realtime.TimeRange application_periods = 4;
  int application_periods_size() const;
  void clear_application_periods();
  static const int kApplicationPeriodsFieldNumber = 4;
  const ::transit_realtime::TimeRange& application_periods(int index) const;
  ::transit_realtime::TimeRange* mutable_application_periods(int index);
  ::transit_realtime::TimeRange* add_application_periods();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_application_periods();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
      application_periods() const;

  // optional .chaos.Severity severity = 5;
  bool has_severity() const;
  void clear_severity();
  static const int kSeverityFieldNumber = 5;
  const ::chaos::Severity& severity() const;
  ::chaos::Severity* mutable_severity();
  ::chaos::Severity* release_severity();
  void set_allocated_severity(::chaos::Severity* severity);

  // repeated .chaos.PtObject informed_entities = 6;
  int informed_entities_size() const;
  void clear_informed_entities();
  static const int kInformedEntitiesFieldNumber = 6;
  const ::chaos::PtObject& informed_entities(int index) const;
  ::chaos::PtObject* mutable_informed_entities(int index);
  ::chaos::PtObject* add_informed_entities();
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
      mutable_informed_entities();
  const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
      informed_entities() const;

  // repeated .chaos.Message messages = 7;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 7;
  const ::chaos::Message& messages(int index) const;
  ::chaos::Message* mutable_messages(int index);
  ::chaos::Message* add_messages();
  ::google::protobuf::RepeatedPtrField< ::chaos::Message >*
      mutable_messages();
  const ::google::protobuf::RepeatedPtrField< ::chaos::Message >&
      messages() const;

  // optional bool send_notifications = 8;
  bool has_send_notifications() const;
  void clear_send_notifications();
  static const int kSendNotificationsFieldNumber = 8;
  bool send_notifications() const;
  void set_send_notifications(bool value);

  // optional uint64 notification_date = 9;
  bool has_notification_date() const;
  void clear_notification_date();
  static const int kNotificationDateFieldNumber = 9;
  ::google::protobuf::uint64 notification_date() const;
  void set_notification_date(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chaos.Impact)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_send_notifications();
  inline void clear_has_send_notifications();
  inline void set_has_notification_date();
  inline void clear_has_notification_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange > application_periods_;
  ::chaos::Severity* severity_;
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject > informed_entities_;
  ::google::protobuf::RepeatedPtrField< ::chaos::Message > messages_;
  ::google::protobuf::uint64 notification_date_;
  bool send_notifications_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Impact* default_instance_;
};
// -------------------------------------------------------------------

class LineSection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.LineSection) */ {
 public:
  LineSection();
  virtual ~LineSection();

  LineSection(const LineSection& from);

  inline LineSection& operator=(const LineSection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineSection& default_instance();

  void Swap(LineSection* other);

  // implements Message ----------------------------------------------

  inline LineSection* New() const { return New(NULL); }

  LineSection* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineSection& from);
  void MergeFrom(const LineSection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LineSection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .chaos.PtObject line = 1;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 1;
  const ::chaos::PtObject& line() const;
  ::chaos::PtObject* mutable_line();
  ::chaos::PtObject* release_line();
  void set_allocated_line(::chaos::PtObject* line);

  // required .chaos.PtObject start_point = 2;
  bool has_start_point() const;
  void clear_start_point();
  static const int kStartPointFieldNumber = 2;
  const ::chaos::PtObject& start_point() const;
  ::chaos::PtObject* mutable_start_point();
  ::chaos::PtObject* release_start_point();
  void set_allocated_start_point(::chaos::PtObject* start_point);

  // required .chaos.PtObject end_point = 3;
  bool has_end_point() const;
  void clear_end_point();
  static const int kEndPointFieldNumber = 3;
  const ::chaos::PtObject& end_point() const;
  ::chaos::PtObject* mutable_end_point();
  ::chaos::PtObject* release_end_point();
  void set_allocated_end_point(::chaos::PtObject* end_point);

  // optional int32 sens = 4;
  bool has_sens() const;
  void clear_sens();
  static const int kSensFieldNumber = 4;
  ::google::protobuf::int32 sens() const;
  void set_sens(::google::protobuf::int32 value);

  // repeated .chaos.PtObject routes = 5;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 5;
  const ::chaos::PtObject& routes(int index) const;
  ::chaos::PtObject* mutable_routes(int index);
  ::chaos::PtObject* add_routes();
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
      routes() const;

  // repeated .chaos.PtObject via = 6;
  int via_size() const;
  void clear_via();
  static const int kViaFieldNumber = 6;
  const ::chaos::PtObject& via(int index) const;
  ::chaos::PtObject* mutable_via(int index);
  ::chaos::PtObject* add_via();
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
      mutable_via();
  const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
      via() const;

  // @@protoc_insertion_point(class_scope:chaos.LineSection)
 private:
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_start_point();
  inline void clear_has_start_point();
  inline void set_has_end_point();
  inline void clear_has_end_point();
  inline void set_has_sens();
  inline void clear_has_sens();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::chaos::PtObject* line_;
  ::chaos::PtObject* start_point_;
  ::chaos::PtObject* end_point_;
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject > routes_;
  ::google::protobuf::RepeatedPtrField< ::chaos::PtObject > via_;
  ::google::protobuf::int32 sens_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static LineSection* default_instance_;
};
// -------------------------------------------------------------------

class PtObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.PtObject) */ {
 public:
  PtObject();
  virtual ~PtObject();

  PtObject(const PtObject& from);

  inline PtObject& operator=(const PtObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PtObject& default_instance();

  void Swap(PtObject* other);

  // implements Message ----------------------------------------------

  inline PtObject* New() const { return New(NULL); }

  PtObject* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PtObject& from);
  void MergeFrom(const PtObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PtObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PtObject_Type Type;
  static const Type network =
    PtObject_Type_network;
  static const Type stop_area =
    PtObject_Type_stop_area;
  static const Type line =
    PtObject_Type_line;
  static const Type line_section =
    PtObject_Type_line_section;
  static const Type route =
    PtObject_Type_route;
  static const Type unkown_type =
    PtObject_Type_unkown_type;
  static const Type stop_point =
    PtObject_Type_stop_point;
  static const Type trip =
    PtObject_Type_trip;
  static inline bool Type_IsValid(int value) {
    return PtObject_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PtObject_Type_Type_MIN;
  static const Type Type_MAX =
    PtObject_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PtObject_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PtObject_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PtObject_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PtObject_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 created_at = 1;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 1;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 2;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 2;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // required .chaos.PtObject.Type pt_object_type = 3;
  bool has_pt_object_type() const;
  void clear_pt_object_type();
  static const int kPtObjectTypeFieldNumber = 3;
  ::chaos::PtObject_Type pt_object_type() const;
  void set_pt_object_type(::chaos::PtObject_Type value);

  // required string uri = 4;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 4;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // optional .chaos.LineSection pt_line_section = 5;
  bool has_pt_line_section() const;
  void clear_pt_line_section();
  static const int kPtLineSectionFieldNumber = 5;
  const ::chaos::LineSection& pt_line_section() const;
  ::chaos::LineSection* mutable_pt_line_section();
  ::chaos::LineSection* release_pt_line_section();
  void set_allocated_pt_line_section(::chaos::LineSection* pt_line_section);

  // @@protoc_insertion_point(class_scope:chaos.PtObject)
 private:
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_pt_object_type();
  inline void clear_has_pt_object_type();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_pt_line_section();
  inline void clear_has_pt_line_section();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::chaos::LineSection* pt_line_section_;
  int pt_object_type_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static PtObject* default_instance_;
};
// -------------------------------------------------------------------

class Severity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Severity) */ {
 public:
  Severity();
  virtual ~Severity();

  Severity(const Severity& from);

  inline Severity& operator=(const Severity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Severity& default_instance();

  void Swap(Severity* other);

  // implements Message ----------------------------------------------

  inline Severity* New() const { return New(NULL); }

  Severity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Severity& from);
  void MergeFrom(const Severity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Severity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string wording = 2;
  bool has_wording() const;
  void clear_wording();
  static const int kWordingFieldNumber = 2;
  const ::std::string& wording() const;
  void set_wording(const ::std::string& value);
  void set_wording(const char* value);
  void set_wording(const char* value, size_t size);
  ::std::string* mutable_wording();
  ::std::string* release_wording();
  void set_allocated_wording(::std::string* wording);

  // optional uint64 created_at = 3;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 3;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 4;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // optional string color = 5;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 5;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // optional int32 priority = 6;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // optional .transit_realtime.Alert.Effect effect = 7;
  bool has_effect() const;
  void clear_effect();
  static const int kEffectFieldNumber = 7;
  ::transit_realtime::Alert_Effect effect() const;
  void set_effect(::transit_realtime::Alert_Effect value);

  // @@protoc_insertion_point(class_scope:chaos.Severity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_wording();
  inline void clear_has_wording();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_effect();
  inline void clear_has_effect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr wording_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::int32 priority_;
  int effect_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Severity* default_instance_;
};
// -------------------------------------------------------------------

class Tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Tag) */ {
 public:
  Tag();
  virtual ~Tag();

  Tag(const Tag& from);

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tag& default_instance();

  void Swap(Tag* other);

  // implements Message ----------------------------------------------

  inline Tag* New() const { return New(NULL); }

  Tag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Tag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 created_at = 3;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 3;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 4;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chaos.Tag)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Tag* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required .chaos.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  const ::chaos::Channel& channel() const;
  ::chaos::Channel* mutable_channel();
  ::chaos::Channel* release_channel();
  void set_allocated_channel(::chaos::Channel* channel);

  // optional uint64 created_at = 3;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 3;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 4;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 4;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // repeated .chaos.Meta meta = 5;
  int meta_size() const;
  void clear_meta();
  static const int kMetaFieldNumber = 5;
  const ::chaos::Meta& meta(int index) const;
  ::chaos::Meta* mutable_meta(int index);
  ::chaos::Meta* add_meta();
  ::google::protobuf::RepeatedPtrField< ::chaos::Meta >*
      mutable_meta();
  const ::google::protobuf::RepeatedPtrField< ::chaos::Meta >&
      meta() const;

  // @@protoc_insertion_point(class_scope:chaos.Message)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::chaos::Channel* channel_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::RepeatedPtrField< ::chaos::Meta > meta_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  void Swap(Channel* other);

  // implements Message ----------------------------------------------

  inline Channel* New() const { return New(NULL); }

  Channel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Channel_Type Type;
  static const Type web =
    Channel_Type_web;
  static const Type sms =
    Channel_Type_sms;
  static const Type email =
    Channel_Type_email;
  static const Type mobile =
    Channel_Type_mobile;
  static const Type notification =
    Channel_Type_notification;
  static const Type twitter =
    Channel_Type_twitter;
  static const Type facebook =
    Channel_Type_facebook;
  static const Type unkown_type =
    Channel_Type_unkown_type;
  static const Type title =
    Channel_Type_title;
  static const Type beacon =
    Channel_Type_beacon;
  static inline bool Type_IsValid(int value) {
    return Channel_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Channel_Type_Type_MIN;
  static const Type Type_MAX =
    Channel_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Channel_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Channel_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Channel_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Channel_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string content_type = 3;
  bool has_content_type() const;
  void clear_content_type();
  static const int kContentTypeFieldNumber = 3;
  const ::std::string& content_type() const;
  void set_content_type(const ::std::string& value);
  void set_content_type(const char* value);
  void set_content_type(const char* value, size_t size);
  ::std::string* mutable_content_type();
  ::std::string* release_content_type();
  void set_allocated_content_type(::std::string* content_type);

  // optional uint32 max_size = 4;
  bool has_max_size() const;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 4;
  ::google::protobuf::uint32 max_size() const;
  void set_max_size(::google::protobuf::uint32 value);

  // optional uint64 created_at = 5;
  bool has_created_at() const;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 5;
  ::google::protobuf::uint64 created_at() const;
  void set_created_at(::google::protobuf::uint64 value);

  // optional uint64 updated_at = 6;
  bool has_updated_at() const;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 6;
  ::google::protobuf::uint64 updated_at() const;
  void set_updated_at(::google::protobuf::uint64 value);

  // repeated .chaos.Channel.Type types = 7;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 7;
  ::chaos::Channel_Type types(int index) const;
  void set_types(int index, ::chaos::Channel_Type value);
  void add_types(::chaos::Channel_Type value);
  const ::google::protobuf::RepeatedField<int>& types() const;
  ::google::protobuf::RepeatedField<int>* mutable_types();

  // @@protoc_insertion_point(class_scope:chaos.Channel)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr content_type_;
  ::google::protobuf::uint64 created_at_;
  ::google::protobuf::uint64 updated_at_;
  ::google::protobuf::RepeatedField<int> types_;
  ::google::protobuf::uint32 max_size_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Channel* default_instance_;
};
// -------------------------------------------------------------------

class DisruptionProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.DisruptionProperty) */ {
 public:
  DisruptionProperty();
  virtual ~DisruptionProperty();

  DisruptionProperty(const DisruptionProperty& from);

  inline DisruptionProperty& operator=(const DisruptionProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisruptionProperty& default_instance();

  void Swap(DisruptionProperty* other);

  // implements Message ----------------------------------------------

  inline DisruptionProperty* New() const { return New(NULL); }

  DisruptionProperty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisruptionProperty& from);
  void MergeFrom(const DisruptionProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisruptionProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:chaos.DisruptionProperty)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static DisruptionProperty* default_instance_;
};
// -------------------------------------------------------------------

class Meta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos.Meta) */ {
 public:
  Meta();
  virtual ~Meta();

  Meta(const Meta& from);

  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Meta& default_instance();

  void Swap(Meta* other);

  // implements Message ----------------------------------------------

  inline Meta* New() const { return New(NULL); }

  Meta* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Meta& from);
  void MergeFrom(const Meta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Meta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:chaos.Meta)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_chaos_2eproto();
  friend void protobuf_AssignDesc_chaos_2eproto();
  friend void protobuf_ShutdownFile_chaos_2eproto();

  void InitAsDefaultInstance();
  static Meta* default_instance_;
};
// ===================================================================

static const int kDisruptionFieldNumber = 1000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::FeedEntity,
    ::google::protobuf::internal::MessageTypeTraits< ::chaos::Disruption >, 11, false >
  disruption;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Disruption

// required string id = 1;
inline bool Disruption::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Disruption::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Disruption::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Disruption::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Disruption::id() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Disruption.id)
}
inline void Disruption::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Disruption.id)
}
inline void Disruption::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Disruption.id)
}
inline ::std::string* Disruption::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disruption::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.id)
}

// optional string reference = 3;
inline bool Disruption::has_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Disruption::set_has_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Disruption::clear_has_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Disruption::clear_reference() {
  reference_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reference();
}
inline const ::std::string& Disruption::reference() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.reference)
  return reference_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_reference(const ::std::string& value) {
  set_has_reference();
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Disruption.reference)
}
inline void Disruption::set_reference(const char* value) {
  set_has_reference();
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Disruption.reference)
}
inline void Disruption::set_reference(const char* value, size_t size) {
  set_has_reference();
  reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Disruption.reference)
}
inline ::std::string* Disruption::mutable_reference() {
  set_has_reference();
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.reference)
  return reference_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disruption::release_reference() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.reference)
  clear_has_reference();
  return reference_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_allocated_reference(::std::string* reference) {
  if (reference != NULL) {
    set_has_reference();
  } else {
    clear_has_reference();
  }
  reference_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reference);
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.reference)
}

// optional .transit_realtime.TimeRange publication_period = 4;
inline bool Disruption::has_publication_period() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Disruption::set_has_publication_period() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Disruption::clear_has_publication_period() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Disruption::clear_publication_period() {
  if (publication_period_ != NULL) publication_period_->::transit_realtime::TimeRange::Clear();
  clear_has_publication_period();
}
inline const ::transit_realtime::TimeRange& Disruption::publication_period() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.publication_period)
  return publication_period_ != NULL ? *publication_period_ : *default_instance_->publication_period_;
}
inline ::transit_realtime::TimeRange* Disruption::mutable_publication_period() {
  set_has_publication_period();
  if (publication_period_ == NULL) {
    publication_period_ = new ::transit_realtime::TimeRange;
  }
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.publication_period)
  return publication_period_;
}
inline ::transit_realtime::TimeRange* Disruption::release_publication_period() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.publication_period)
  clear_has_publication_period();
  ::transit_realtime::TimeRange* temp = publication_period_;
  publication_period_ = NULL;
  return temp;
}
inline void Disruption::set_allocated_publication_period(::transit_realtime::TimeRange* publication_period) {
  delete publication_period_;
  publication_period_ = publication_period;
  if (publication_period) {
    set_has_publication_period();
  } else {
    clear_has_publication_period();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.publication_period)
}

// optional uint64 created_at = 6;
inline bool Disruption::has_created_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Disruption::set_has_created_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Disruption::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Disruption::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Disruption::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.created_at)
  return created_at_;
}
inline void Disruption::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Disruption.created_at)
}

// optional uint64 updated_at = 7;
inline bool Disruption::has_updated_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Disruption::set_has_updated_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Disruption::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Disruption::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Disruption::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.updated_at)
  return updated_at_;
}
inline void Disruption::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Disruption.updated_at)
}

// optional .chaos.Cause cause = 8;
inline bool Disruption::has_cause() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Disruption::set_has_cause() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Disruption::clear_has_cause() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Disruption::clear_cause() {
  if (cause_ != NULL) cause_->::chaos::Cause::Clear();
  clear_has_cause();
}
inline const ::chaos::Cause& Disruption::cause() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.cause)
  return cause_ != NULL ? *cause_ : *default_instance_->cause_;
}
inline ::chaos::Cause* Disruption::mutable_cause() {
  set_has_cause();
  if (cause_ == NULL) {
    cause_ = new ::chaos::Cause;
  }
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.cause)
  return cause_;
}
inline ::chaos::Cause* Disruption::release_cause() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.cause)
  clear_has_cause();
  ::chaos::Cause* temp = cause_;
  cause_ = NULL;
  return temp;
}
inline void Disruption::set_allocated_cause(::chaos::Cause* cause) {
  delete cause_;
  cause_ = cause;
  if (cause) {
    set_has_cause();
  } else {
    clear_has_cause();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.cause)
}

// repeated .chaos.Impact impacts = 9;
inline int Disruption::impacts_size() const {
  return impacts_.size();
}
inline void Disruption::clear_impacts() {
  impacts_.Clear();
}
inline const ::chaos::Impact& Disruption::impacts(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.impacts)
  return impacts_.Get(index);
}
inline ::chaos::Impact* Disruption::mutable_impacts(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.impacts)
  return impacts_.Mutable(index);
}
inline ::chaos::Impact* Disruption::add_impacts() {
  // @@protoc_insertion_point(field_add:chaos.Disruption.impacts)
  return impacts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::Impact >*
Disruption::mutable_impacts() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Disruption.impacts)
  return &impacts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::Impact >&
Disruption::impacts() const {
  // @@protoc_insertion_point(field_list:chaos.Disruption.impacts)
  return impacts_;
}

// repeated .chaos.Tag tags = 11;
inline int Disruption::tags_size() const {
  return tags_.size();
}
inline void Disruption::clear_tags() {
  tags_.Clear();
}
inline const ::chaos::Tag& Disruption::tags(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.tags)
  return tags_.Get(index);
}
inline ::chaos::Tag* Disruption::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.tags)
  return tags_.Mutable(index);
}
inline ::chaos::Tag* Disruption::add_tags() {
  // @@protoc_insertion_point(field_add:chaos.Disruption.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::Tag >*
Disruption::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Disruption.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::Tag >&
Disruption::tags() const {
  // @@protoc_insertion_point(field_list:chaos.Disruption.tags)
  return tags_;
}

// optional string note = 12;
inline bool Disruption::has_note() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Disruption::set_has_note() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Disruption::clear_has_note() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Disruption::clear_note() {
  note_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_note();
}
inline const ::std::string& Disruption::note() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.note)
  return note_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_note(const ::std::string& value) {
  set_has_note();
  note_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Disruption.note)
}
inline void Disruption::set_note(const char* value) {
  set_has_note();
  note_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Disruption.note)
}
inline void Disruption::set_note(const char* value, size_t size) {
  set_has_note();
  note_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Disruption.note)
}
inline ::std::string* Disruption::mutable_note() {
  set_has_note();
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.note)
  return note_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disruption::release_note() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.note)
  clear_has_note();
  return note_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_allocated_note(::std::string* note) {
  if (note != NULL) {
    set_has_note();
  } else {
    clear_has_note();
  }
  note_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), note);
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.note)
}

// repeated .chaos.PtObject localization = 13;
inline int Disruption::localization_size() const {
  return localization_.size();
}
inline void Disruption::clear_localization() {
  localization_.Clear();
}
inline const ::chaos::PtObject& Disruption::localization(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.localization)
  return localization_.Get(index);
}
inline ::chaos::PtObject* Disruption::mutable_localization(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.localization)
  return localization_.Mutable(index);
}
inline ::chaos::PtObject* Disruption::add_localization() {
  // @@protoc_insertion_point(field_add:chaos.Disruption.localization)
  return localization_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
Disruption::mutable_localization() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Disruption.localization)
  return &localization_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
Disruption::localization() const {
  // @@protoc_insertion_point(field_list:chaos.Disruption.localization)
  return localization_;
}

// optional string contributor = 14;
inline bool Disruption::has_contributor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Disruption::set_has_contributor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Disruption::clear_has_contributor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Disruption::clear_contributor() {
  contributor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contributor();
}
inline const ::std::string& Disruption::contributor() const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.contributor)
  return contributor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_contributor(const ::std::string& value) {
  set_has_contributor();
  contributor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Disruption.contributor)
}
inline void Disruption::set_contributor(const char* value) {
  set_has_contributor();
  contributor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Disruption.contributor)
}
inline void Disruption::set_contributor(const char* value, size_t size) {
  set_has_contributor();
  contributor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Disruption.contributor)
}
inline ::std::string* Disruption::mutable_contributor() {
  set_has_contributor();
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.contributor)
  return contributor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disruption::release_contributor() {
  // @@protoc_insertion_point(field_release:chaos.Disruption.contributor)
  clear_has_contributor();
  return contributor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disruption::set_allocated_contributor(::std::string* contributor) {
  if (contributor != NULL) {
    set_has_contributor();
  } else {
    clear_has_contributor();
  }
  contributor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contributor);
  // @@protoc_insertion_point(field_set_allocated:chaos.Disruption.contributor)
}

// repeated .chaos.DisruptionProperty properties = 15;
inline int Disruption::properties_size() const {
  return properties_.size();
}
inline void Disruption::clear_properties() {
  properties_.Clear();
}
inline const ::chaos::DisruptionProperty& Disruption::properties(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Disruption.properties)
  return properties_.Get(index);
}
inline ::chaos::DisruptionProperty* Disruption::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Disruption.properties)
  return properties_.Mutable(index);
}
inline ::chaos::DisruptionProperty* Disruption::add_properties() {
  // @@protoc_insertion_point(field_add:chaos.Disruption.properties)
  return properties_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::DisruptionProperty >*
Disruption::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Disruption.properties)
  return &properties_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::DisruptionProperty >&
Disruption::properties() const {
  // @@protoc_insertion_point(field_list:chaos.Disruption.properties)
  return properties_;
}

// -------------------------------------------------------------------

// Wording

// required string key = 1;
inline bool Wording::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wording::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wording::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wording::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Wording::key() const {
  // @@protoc_insertion_point(field_get:chaos.Wording.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wording::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Wording.key)
}
inline void Wording::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Wording.key)
}
inline void Wording::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Wording.key)
}
inline ::std::string* Wording::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:chaos.Wording.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Wording::release_key() {
  // @@protoc_insertion_point(field_release:chaos.Wording.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wording::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chaos.Wording.key)
}

// required string value = 2;
inline bool Wording::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wording::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wording::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wording::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Wording::value() const {
  // @@protoc_insertion_point(field_get:chaos.Wording.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wording::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Wording.value)
}
inline void Wording::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Wording.value)
}
inline void Wording::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Wording.value)
}
inline ::std::string* Wording::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:chaos.Wording.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Wording::release_value() {
  // @@protoc_insertion_point(field_release:chaos.Wording.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wording::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:chaos.Wording.value)
}

// -------------------------------------------------------------------

// Category

// required string id = 1;
inline bool Category::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Category::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Category::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Category::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Category::id() const {
  // @@protoc_insertion_point(field_get:chaos.Category.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Category.id)
}
inline void Category::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Category.id)
}
inline void Category::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Category.id)
}
inline ::std::string* Category::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Category.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Category.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Category.id)
}

// required string name = 2;
inline bool Category::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Category::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Category::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Category::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Category::name() const {
  // @@protoc_insertion_point(field_get:chaos.Category.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Category.name)
}
inline void Category::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Category.name)
}
inline void Category::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Category.name)
}
inline ::std::string* Category::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:chaos.Category.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_name() {
  // @@protoc_insertion_point(field_release:chaos.Category.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chaos.Category.name)
}

// optional uint64 created_at = 3;
inline bool Category::has_created_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Category::set_has_created_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Category::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Category::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Category::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Category.created_at)
  return created_at_;
}
inline void Category::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Category.created_at)
}

// optional uint64 updated_at = 4;
inline bool Category::has_updated_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Category::set_has_updated_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Category::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Category::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Category::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Category.updated_at)
  return updated_at_;
}
inline void Category::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Category.updated_at)
}

// -------------------------------------------------------------------

// Cause

// required string id = 1;
inline bool Cause::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cause::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cause::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cause::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Cause::id() const {
  // @@protoc_insertion_point(field_get:chaos.Cause.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cause::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Cause.id)
}
inline void Cause::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Cause.id)
}
inline void Cause::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Cause.id)
}
inline ::std::string* Cause::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Cause.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cause::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Cause.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cause::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Cause.id)
}

// optional string wording = 2;
inline bool Cause::has_wording() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cause::set_has_wording() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cause::clear_has_wording() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cause::clear_wording() {
  wording_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wording();
}
inline const ::std::string& Cause::wording() const {
  // @@protoc_insertion_point(field_get:chaos.Cause.wording)
  return wording_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cause::set_wording(const ::std::string& value) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Cause.wording)
}
inline void Cause::set_wording(const char* value) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Cause.wording)
}
inline void Cause::set_wording(const char* value, size_t size) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Cause.wording)
}
inline ::std::string* Cause::mutable_wording() {
  set_has_wording();
  // @@protoc_insertion_point(field_mutable:chaos.Cause.wording)
  return wording_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cause::release_wording() {
  // @@protoc_insertion_point(field_release:chaos.Cause.wording)
  clear_has_wording();
  return wording_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cause::set_allocated_wording(::std::string* wording) {
  if (wording != NULL) {
    set_has_wording();
  } else {
    clear_has_wording();
  }
  wording_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wording);
  // @@protoc_insertion_point(field_set_allocated:chaos.Cause.wording)
}

// optional uint64 created_at = 3;
inline bool Cause::has_created_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cause::set_has_created_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cause::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cause::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Cause::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Cause.created_at)
  return created_at_;
}
inline void Cause::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Cause.created_at)
}

// optional uint64 updated_at = 4;
inline bool Cause::has_updated_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cause::set_has_updated_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cause::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cause::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Cause::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Cause.updated_at)
  return updated_at_;
}
inline void Cause::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Cause.updated_at)
}

// repeated .chaos.Wording wordings = 5;
inline int Cause::wordings_size() const {
  return wordings_.size();
}
inline void Cause::clear_wordings() {
  wordings_.Clear();
}
inline const ::chaos::Wording& Cause::wordings(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Cause.wordings)
  return wordings_.Get(index);
}
inline ::chaos::Wording* Cause::mutable_wordings(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Cause.wordings)
  return wordings_.Mutable(index);
}
inline ::chaos::Wording* Cause::add_wordings() {
  // @@protoc_insertion_point(field_add:chaos.Cause.wordings)
  return wordings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::Wording >*
Cause::mutable_wordings() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Cause.wordings)
  return &wordings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::Wording >&
Cause::wordings() const {
  // @@protoc_insertion_point(field_list:chaos.Cause.wordings)
  return wordings_;
}

// optional .chaos.Category category = 6;
inline bool Cause::has_category() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cause::set_has_category() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Cause::clear_has_category() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Cause::clear_category() {
  if (category_ != NULL) category_->::chaos::Category::Clear();
  clear_has_category();
}
inline const ::chaos::Category& Cause::category() const {
  // @@protoc_insertion_point(field_get:chaos.Cause.category)
  return category_ != NULL ? *category_ : *default_instance_->category_;
}
inline ::chaos::Category* Cause::mutable_category() {
  set_has_category();
  if (category_ == NULL) {
    category_ = new ::chaos::Category;
  }
  // @@protoc_insertion_point(field_mutable:chaos.Cause.category)
  return category_;
}
inline ::chaos::Category* Cause::release_category() {
  // @@protoc_insertion_point(field_release:chaos.Cause.category)
  clear_has_category();
  ::chaos::Category* temp = category_;
  category_ = NULL;
  return temp;
}
inline void Cause::set_allocated_category(::chaos::Category* category) {
  delete category_;
  category_ = category;
  if (category) {
    set_has_category();
  } else {
    clear_has_category();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.Cause.category)
}

// -------------------------------------------------------------------

// Impact

// required string id = 1;
inline bool Impact::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Impact::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Impact::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Impact::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Impact::id() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Impact::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Impact.id)
}
inline void Impact::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Impact.id)
}
inline void Impact::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Impact.id)
}
inline ::std::string* Impact::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Impact.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Impact::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Impact.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Impact::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Impact.id)
}

// optional uint64 created_at = 2;
inline bool Impact::has_created_at() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Impact::set_has_created_at() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Impact::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Impact::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Impact::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.created_at)
  return created_at_;
}
inline void Impact::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Impact.created_at)
}

// optional uint64 updated_at = 3;
inline bool Impact::has_updated_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Impact::set_has_updated_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Impact::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Impact::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Impact::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.updated_at)
  return updated_at_;
}
inline void Impact::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Impact.updated_at)
}

// repeated .transit_realtime.TimeRange application_periods = 4;
inline int Impact::application_periods_size() const {
  return application_periods_.size();
}
inline void Impact::clear_application_periods() {
  application_periods_.Clear();
}
inline const ::transit_realtime::TimeRange& Impact::application_periods(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Impact.application_periods)
  return application_periods_.Get(index);
}
inline ::transit_realtime::TimeRange* Impact::mutable_application_periods(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Impact.application_periods)
  return application_periods_.Mutable(index);
}
inline ::transit_realtime::TimeRange* Impact::add_application_periods() {
  // @@protoc_insertion_point(field_add:chaos.Impact.application_periods)
  return application_periods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
Impact::mutable_application_periods() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Impact.application_periods)
  return &application_periods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
Impact::application_periods() const {
  // @@protoc_insertion_point(field_list:chaos.Impact.application_periods)
  return application_periods_;
}

// optional .chaos.Severity severity = 5;
inline bool Impact::has_severity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Impact::set_has_severity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Impact::clear_has_severity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Impact::clear_severity() {
  if (severity_ != NULL) severity_->::chaos::Severity::Clear();
  clear_has_severity();
}
inline const ::chaos::Severity& Impact::severity() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.severity)
  return severity_ != NULL ? *severity_ : *default_instance_->severity_;
}
inline ::chaos::Severity* Impact::mutable_severity() {
  set_has_severity();
  if (severity_ == NULL) {
    severity_ = new ::chaos::Severity;
  }
  // @@protoc_insertion_point(field_mutable:chaos.Impact.severity)
  return severity_;
}
inline ::chaos::Severity* Impact::release_severity() {
  // @@protoc_insertion_point(field_release:chaos.Impact.severity)
  clear_has_severity();
  ::chaos::Severity* temp = severity_;
  severity_ = NULL;
  return temp;
}
inline void Impact::set_allocated_severity(::chaos::Severity* severity) {
  delete severity_;
  severity_ = severity;
  if (severity) {
    set_has_severity();
  } else {
    clear_has_severity();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.Impact.severity)
}

// repeated .chaos.PtObject informed_entities = 6;
inline int Impact::informed_entities_size() const {
  return informed_entities_.size();
}
inline void Impact::clear_informed_entities() {
  informed_entities_.Clear();
}
inline const ::chaos::PtObject& Impact::informed_entities(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Impact.informed_entities)
  return informed_entities_.Get(index);
}
inline ::chaos::PtObject* Impact::mutable_informed_entities(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Impact.informed_entities)
  return informed_entities_.Mutable(index);
}
inline ::chaos::PtObject* Impact::add_informed_entities() {
  // @@protoc_insertion_point(field_add:chaos.Impact.informed_entities)
  return informed_entities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
Impact::mutable_informed_entities() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Impact.informed_entities)
  return &informed_entities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
Impact::informed_entities() const {
  // @@protoc_insertion_point(field_list:chaos.Impact.informed_entities)
  return informed_entities_;
}

// repeated .chaos.Message messages = 7;
inline int Impact::messages_size() const {
  return messages_.size();
}
inline void Impact::clear_messages() {
  messages_.Clear();
}
inline const ::chaos::Message& Impact::messages(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Impact.messages)
  return messages_.Get(index);
}
inline ::chaos::Message* Impact::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Impact.messages)
  return messages_.Mutable(index);
}
inline ::chaos::Message* Impact::add_messages() {
  // @@protoc_insertion_point(field_add:chaos.Impact.messages)
  return messages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::Message >*
Impact::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Impact.messages)
  return &messages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::Message >&
Impact::messages() const {
  // @@protoc_insertion_point(field_list:chaos.Impact.messages)
  return messages_;
}

// optional bool send_notifications = 8;
inline bool Impact::has_send_notifications() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Impact::set_has_send_notifications() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Impact::clear_has_send_notifications() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Impact::clear_send_notifications() {
  send_notifications_ = false;
  clear_has_send_notifications();
}
inline bool Impact::send_notifications() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.send_notifications)
  return send_notifications_;
}
inline void Impact::set_send_notifications(bool value) {
  set_has_send_notifications();
  send_notifications_ = value;
  // @@protoc_insertion_point(field_set:chaos.Impact.send_notifications)
}

// optional uint64 notification_date = 9;
inline bool Impact::has_notification_date() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Impact::set_has_notification_date() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Impact::clear_has_notification_date() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Impact::clear_notification_date() {
  notification_date_ = GOOGLE_ULONGLONG(0);
  clear_has_notification_date();
}
inline ::google::protobuf::uint64 Impact::notification_date() const {
  // @@protoc_insertion_point(field_get:chaos.Impact.notification_date)
  return notification_date_;
}
inline void Impact::set_notification_date(::google::protobuf::uint64 value) {
  set_has_notification_date();
  notification_date_ = value;
  // @@protoc_insertion_point(field_set:chaos.Impact.notification_date)
}

// -------------------------------------------------------------------

// LineSection

// required .chaos.PtObject line = 1;
inline bool LineSection::has_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineSection::set_has_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineSection::clear_has_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineSection::clear_line() {
  if (line_ != NULL) line_->::chaos::PtObject::Clear();
  clear_has_line();
}
inline const ::chaos::PtObject& LineSection::line() const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.line)
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::chaos::PtObject* LineSection::mutable_line() {
  set_has_line();
  if (line_ == NULL) {
    line_ = new ::chaos::PtObject;
  }
  // @@protoc_insertion_point(field_mutable:chaos.LineSection.line)
  return line_;
}
inline ::chaos::PtObject* LineSection::release_line() {
  // @@protoc_insertion_point(field_release:chaos.LineSection.line)
  clear_has_line();
  ::chaos::PtObject* temp = line_;
  line_ = NULL;
  return temp;
}
inline void LineSection::set_allocated_line(::chaos::PtObject* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.LineSection.line)
}

// required .chaos.PtObject start_point = 2;
inline bool LineSection::has_start_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineSection::set_has_start_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineSection::clear_has_start_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineSection::clear_start_point() {
  if (start_point_ != NULL) start_point_->::chaos::PtObject::Clear();
  clear_has_start_point();
}
inline const ::chaos::PtObject& LineSection::start_point() const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.start_point)
  return start_point_ != NULL ? *start_point_ : *default_instance_->start_point_;
}
inline ::chaos::PtObject* LineSection::mutable_start_point() {
  set_has_start_point();
  if (start_point_ == NULL) {
    start_point_ = new ::chaos::PtObject;
  }
  // @@protoc_insertion_point(field_mutable:chaos.LineSection.start_point)
  return start_point_;
}
inline ::chaos::PtObject* LineSection::release_start_point() {
  // @@protoc_insertion_point(field_release:chaos.LineSection.start_point)
  clear_has_start_point();
  ::chaos::PtObject* temp = start_point_;
  start_point_ = NULL;
  return temp;
}
inline void LineSection::set_allocated_start_point(::chaos::PtObject* start_point) {
  delete start_point_;
  start_point_ = start_point;
  if (start_point) {
    set_has_start_point();
  } else {
    clear_has_start_point();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.LineSection.start_point)
}

// required .chaos.PtObject end_point = 3;
inline bool LineSection::has_end_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineSection::set_has_end_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineSection::clear_has_end_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineSection::clear_end_point() {
  if (end_point_ != NULL) end_point_->::chaos::PtObject::Clear();
  clear_has_end_point();
}
inline const ::chaos::PtObject& LineSection::end_point() const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.end_point)
  return end_point_ != NULL ? *end_point_ : *default_instance_->end_point_;
}
inline ::chaos::PtObject* LineSection::mutable_end_point() {
  set_has_end_point();
  if (end_point_ == NULL) {
    end_point_ = new ::chaos::PtObject;
  }
  // @@protoc_insertion_point(field_mutable:chaos.LineSection.end_point)
  return end_point_;
}
inline ::chaos::PtObject* LineSection::release_end_point() {
  // @@protoc_insertion_point(field_release:chaos.LineSection.end_point)
  clear_has_end_point();
  ::chaos::PtObject* temp = end_point_;
  end_point_ = NULL;
  return temp;
}
inline void LineSection::set_allocated_end_point(::chaos::PtObject* end_point) {
  delete end_point_;
  end_point_ = end_point;
  if (end_point) {
    set_has_end_point();
  } else {
    clear_has_end_point();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.LineSection.end_point)
}

// optional int32 sens = 4;
inline bool LineSection::has_sens() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineSection::set_has_sens() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineSection::clear_has_sens() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineSection::clear_sens() {
  sens_ = 0;
  clear_has_sens();
}
inline ::google::protobuf::int32 LineSection::sens() const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.sens)
  return sens_;
}
inline void LineSection::set_sens(::google::protobuf::int32 value) {
  set_has_sens();
  sens_ = value;
  // @@protoc_insertion_point(field_set:chaos.LineSection.sens)
}

// repeated .chaos.PtObject routes = 5;
inline int LineSection::routes_size() const {
  return routes_.size();
}
inline void LineSection::clear_routes() {
  routes_.Clear();
}
inline const ::chaos::PtObject& LineSection::routes(int index) const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.routes)
  return routes_.Get(index);
}
inline ::chaos::PtObject* LineSection::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.LineSection.routes)
  return routes_.Mutable(index);
}
inline ::chaos::PtObject* LineSection::add_routes() {
  // @@protoc_insertion_point(field_add:chaos.LineSection.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
LineSection::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:chaos.LineSection.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
LineSection::routes() const {
  // @@protoc_insertion_point(field_list:chaos.LineSection.routes)
  return routes_;
}

// repeated .chaos.PtObject via = 6;
inline int LineSection::via_size() const {
  return via_.size();
}
inline void LineSection::clear_via() {
  via_.Clear();
}
inline const ::chaos::PtObject& LineSection::via(int index) const {
  // @@protoc_insertion_point(field_get:chaos.LineSection.via)
  return via_.Get(index);
}
inline ::chaos::PtObject* LineSection::mutable_via(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.LineSection.via)
  return via_.Mutable(index);
}
inline ::chaos::PtObject* LineSection::add_via() {
  // @@protoc_insertion_point(field_add:chaos.LineSection.via)
  return via_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >*
LineSection::mutable_via() {
  // @@protoc_insertion_point(field_mutable_list:chaos.LineSection.via)
  return &via_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::PtObject >&
LineSection::via() const {
  // @@protoc_insertion_point(field_list:chaos.LineSection.via)
  return via_;
}

// -------------------------------------------------------------------

// PtObject

// optional uint64 created_at = 1;
inline bool PtObject::has_created_at() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PtObject::set_has_created_at() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PtObject::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PtObject::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 PtObject::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.PtObject.created_at)
  return created_at_;
}
inline void PtObject::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.PtObject.created_at)
}

// optional uint64 updated_at = 2;
inline bool PtObject::has_updated_at() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PtObject::set_has_updated_at() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PtObject::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PtObject::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 PtObject::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.PtObject.updated_at)
  return updated_at_;
}
inline void PtObject::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.PtObject.updated_at)
}

// required .chaos.PtObject.Type pt_object_type = 3;
inline bool PtObject::has_pt_object_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PtObject::set_has_pt_object_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PtObject::clear_has_pt_object_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PtObject::clear_pt_object_type() {
  pt_object_type_ = 1;
  clear_has_pt_object_type();
}
inline ::chaos::PtObject_Type PtObject::pt_object_type() const {
  // @@protoc_insertion_point(field_get:chaos.PtObject.pt_object_type)
  return static_cast< ::chaos::PtObject_Type >(pt_object_type_);
}
inline void PtObject::set_pt_object_type(::chaos::PtObject_Type value) {
  assert(::chaos::PtObject_Type_IsValid(value));
  set_has_pt_object_type();
  pt_object_type_ = value;
  // @@protoc_insertion_point(field_set:chaos.PtObject.pt_object_type)
}

// required string uri = 4;
inline bool PtObject::has_uri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PtObject::set_has_uri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PtObject::clear_has_uri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PtObject::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& PtObject::uri() const {
  // @@protoc_insertion_point(field_get:chaos.PtObject.uri)
  return uri_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PtObject::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.PtObject.uri)
}
inline void PtObject::set_uri(const char* value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.PtObject.uri)
}
inline void PtObject::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.PtObject.uri)
}
inline ::std::string* PtObject::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:chaos.PtObject.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PtObject::release_uri() {
  // @@protoc_insertion_point(field_release:chaos.PtObject.uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PtObject::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:chaos.PtObject.uri)
}

// optional .chaos.LineSection pt_line_section = 5;
inline bool PtObject::has_pt_line_section() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PtObject::set_has_pt_line_section() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PtObject::clear_has_pt_line_section() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PtObject::clear_pt_line_section() {
  if (pt_line_section_ != NULL) pt_line_section_->::chaos::LineSection::Clear();
  clear_has_pt_line_section();
}
inline const ::chaos::LineSection& PtObject::pt_line_section() const {
  // @@protoc_insertion_point(field_get:chaos.PtObject.pt_line_section)
  return pt_line_section_ != NULL ? *pt_line_section_ : *default_instance_->pt_line_section_;
}
inline ::chaos::LineSection* PtObject::mutable_pt_line_section() {
  set_has_pt_line_section();
  if (pt_line_section_ == NULL) {
    pt_line_section_ = new ::chaos::LineSection;
  }
  // @@protoc_insertion_point(field_mutable:chaos.PtObject.pt_line_section)
  return pt_line_section_;
}
inline ::chaos::LineSection* PtObject::release_pt_line_section() {
  // @@protoc_insertion_point(field_release:chaos.PtObject.pt_line_section)
  clear_has_pt_line_section();
  ::chaos::LineSection* temp = pt_line_section_;
  pt_line_section_ = NULL;
  return temp;
}
inline void PtObject::set_allocated_pt_line_section(::chaos::LineSection* pt_line_section) {
  delete pt_line_section_;
  pt_line_section_ = pt_line_section;
  if (pt_line_section) {
    set_has_pt_line_section();
  } else {
    clear_has_pt_line_section();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.PtObject.pt_line_section)
}

// -------------------------------------------------------------------

// Severity

// required string id = 1;
inline bool Severity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Severity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Severity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Severity::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Severity::id() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Severity.id)
}
inline void Severity::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Severity.id)
}
inline void Severity::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Severity.id)
}
inline ::std::string* Severity::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Severity.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Severity::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Severity.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Severity.id)
}

// optional string wording = 2;
inline bool Severity::has_wording() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Severity::set_has_wording() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Severity::clear_has_wording() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Severity::clear_wording() {
  wording_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wording();
}
inline const ::std::string& Severity::wording() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.wording)
  return wording_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_wording(const ::std::string& value) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Severity.wording)
}
inline void Severity::set_wording(const char* value) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Severity.wording)
}
inline void Severity::set_wording(const char* value, size_t size) {
  set_has_wording();
  wording_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Severity.wording)
}
inline ::std::string* Severity::mutable_wording() {
  set_has_wording();
  // @@protoc_insertion_point(field_mutable:chaos.Severity.wording)
  return wording_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Severity::release_wording() {
  // @@protoc_insertion_point(field_release:chaos.Severity.wording)
  clear_has_wording();
  return wording_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_allocated_wording(::std::string* wording) {
  if (wording != NULL) {
    set_has_wording();
  } else {
    clear_has_wording();
  }
  wording_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wording);
  // @@protoc_insertion_point(field_set_allocated:chaos.Severity.wording)
}

// optional uint64 created_at = 3;
inline bool Severity::has_created_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Severity::set_has_created_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Severity::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Severity::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Severity::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.created_at)
  return created_at_;
}
inline void Severity::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Severity.created_at)
}

// optional uint64 updated_at = 4;
inline bool Severity::has_updated_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Severity::set_has_updated_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Severity::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Severity::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Severity::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.updated_at)
  return updated_at_;
}
inline void Severity::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Severity.updated_at)
}

// optional string color = 5;
inline bool Severity::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Severity::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Severity::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Severity::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_color();
}
inline const ::std::string& Severity::color() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.color)
  return color_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_color(const ::std::string& value) {
  set_has_color();
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Severity.color)
}
inline void Severity::set_color(const char* value) {
  set_has_color();
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Severity.color)
}
inline void Severity::set_color(const char* value, size_t size) {
  set_has_color();
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Severity.color)
}
inline ::std::string* Severity::mutable_color() {
  set_has_color();
  // @@protoc_insertion_point(field_mutable:chaos.Severity.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Severity::release_color() {
  // @@protoc_insertion_point(field_release:chaos.Severity.color)
  clear_has_color();
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Severity::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    set_has_color();
  } else {
    clear_has_color();
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:chaos.Severity.color)
}

// optional int32 priority = 6;
inline bool Severity::has_priority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Severity::set_has_priority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Severity::clear_has_priority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Severity::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Severity::priority() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.priority)
  return priority_;
}
inline void Severity::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:chaos.Severity.priority)
}

// optional .transit_realtime.Alert.Effect effect = 7;
inline bool Severity::has_effect() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Severity::set_has_effect() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Severity::clear_has_effect() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Severity::clear_effect() {
  effect_ = 1;
  clear_has_effect();
}
inline ::transit_realtime::Alert_Effect Severity::effect() const {
  // @@protoc_insertion_point(field_get:chaos.Severity.effect)
  return static_cast< ::transit_realtime::Alert_Effect >(effect_);
}
inline void Severity::set_effect(::transit_realtime::Alert_Effect value) {
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  set_has_effect();
  effect_ = value;
  // @@protoc_insertion_point(field_set:chaos.Severity.effect)
}

// -------------------------------------------------------------------

// Tag

// required string id = 1;
inline bool Tag::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tag::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tag::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tag::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Tag::id() const {
  // @@protoc_insertion_point(field_get:chaos.Tag.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tag::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Tag.id)
}
inline void Tag::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Tag.id)
}
inline void Tag::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Tag.id)
}
inline ::std::string* Tag::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Tag.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tag::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Tag.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tag::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Tag.id)
}

// required string name = 2;
inline bool Tag::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tag::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tag::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tag::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Tag::name() const {
  // @@protoc_insertion_point(field_get:chaos.Tag.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tag::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Tag.name)
}
inline void Tag::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Tag.name)
}
inline void Tag::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Tag.name)
}
inline ::std::string* Tag::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:chaos.Tag.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tag::release_name() {
  // @@protoc_insertion_point(field_release:chaos.Tag.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tag::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chaos.Tag.name)
}

// optional uint64 created_at = 3;
inline bool Tag::has_created_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tag::set_has_created_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tag::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tag::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Tag::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Tag.created_at)
  return created_at_;
}
inline void Tag::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Tag.created_at)
}

// optional uint64 updated_at = 4;
inline bool Tag::has_updated_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tag::set_has_updated_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tag::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tag::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Tag::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Tag.updated_at)
  return updated_at_;
}
inline void Tag::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Tag.updated_at)
}

// -------------------------------------------------------------------

// Message

// required string text = 1;
inline bool Message::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Message::text() const {
  // @@protoc_insertion_point(field_get:chaos.Message.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Message.text)
}
inline void Message::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Message.text)
}
inline void Message::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Message.text)
}
inline ::std::string* Message::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:chaos.Message.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_text() {
  // @@protoc_insertion_point(field_release:chaos.Message.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:chaos.Message.text)
}

// required .chaos.Channel channel = 2;
inline bool Message::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_channel() {
  if (channel_ != NULL) channel_->::chaos::Channel::Clear();
  clear_has_channel();
}
inline const ::chaos::Channel& Message::channel() const {
  // @@protoc_insertion_point(field_get:chaos.Message.channel)
  return channel_ != NULL ? *channel_ : *default_instance_->channel_;
}
inline ::chaos::Channel* Message::mutable_channel() {
  set_has_channel();
  if (channel_ == NULL) {
    channel_ = new ::chaos::Channel;
  }
  // @@protoc_insertion_point(field_mutable:chaos.Message.channel)
  return channel_;
}
inline ::chaos::Channel* Message::release_channel() {
  // @@protoc_insertion_point(field_release:chaos.Message.channel)
  clear_has_channel();
  ::chaos::Channel* temp = channel_;
  channel_ = NULL;
  return temp;
}
inline void Message::set_allocated_channel(::chaos::Channel* channel) {
  delete channel_;
  channel_ = channel;
  if (channel) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos.Message.channel)
}

// optional uint64 created_at = 3;
inline bool Message::has_created_at() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_created_at() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Message::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Message.created_at)
  return created_at_;
}
inline void Message::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Message.created_at)
}

// optional uint64 updated_at = 4;
inline bool Message::has_updated_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_updated_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Message::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Message.updated_at)
  return updated_at_;
}
inline void Message::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Message.updated_at)
}

// repeated .chaos.Meta meta = 5;
inline int Message::meta_size() const {
  return meta_.size();
}
inline void Message::clear_meta() {
  meta_.Clear();
}
inline const ::chaos::Meta& Message::meta(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Message.meta)
  return meta_.Get(index);
}
inline ::chaos::Meta* Message::mutable_meta(int index) {
  // @@protoc_insertion_point(field_mutable:chaos.Message.meta)
  return meta_.Mutable(index);
}
inline ::chaos::Meta* Message::add_meta() {
  // @@protoc_insertion_point(field_add:chaos.Message.meta)
  return meta_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chaos::Meta >*
Message::mutable_meta() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Message.meta)
  return &meta_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chaos::Meta >&
Message::meta() const {
  // @@protoc_insertion_point(field_list:chaos.Message.meta)
  return meta_;
}

// -------------------------------------------------------------------

// Channel

// required string id = 1;
inline bool Channel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Channel::id() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Channel.id)
}
inline void Channel::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Channel.id)
}
inline void Channel::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Channel.id)
}
inline ::std::string* Channel::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:chaos.Channel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_id() {
  // @@protoc_insertion_point(field_release:chaos.Channel.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:chaos.Channel.id)
}

// optional string name = 2;
inline bool Channel::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Channel::name() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Channel.name)
}
inline void Channel::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Channel.name)
}
inline void Channel::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Channel.name)
}
inline ::std::string* Channel::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:chaos.Channel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_name() {
  // @@protoc_insertion_point(field_release:chaos.Channel.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chaos.Channel.name)
}

// optional string content_type = 3;
inline bool Channel::has_content_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_content_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_content_type() {
  content_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content_type();
}
inline const ::std::string& Channel::content_type() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.content_type)
  return content_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_content_type(const ::std::string& value) {
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Channel.content_type)
}
inline void Channel::set_content_type(const char* value) {
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Channel.content_type)
}
inline void Channel::set_content_type(const char* value, size_t size) {
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Channel.content_type)
}
inline ::std::string* Channel::mutable_content_type() {
  set_has_content_type();
  // @@protoc_insertion_point(field_mutable:chaos.Channel.content_type)
  return content_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_content_type() {
  // @@protoc_insertion_point(field_release:chaos.Channel.content_type)
  clear_has_content_type();
  return content_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_content_type(::std::string* content_type) {
  if (content_type != NULL) {
    set_has_content_type();
  } else {
    clear_has_content_type();
  }
  content_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_type);
  // @@protoc_insertion_point(field_set_allocated:chaos.Channel.content_type)
}

// optional uint32 max_size = 4;
inline bool Channel::has_max_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_max_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_max_size() {
  max_size_ = 0u;
  clear_has_max_size();
}
inline ::google::protobuf::uint32 Channel::max_size() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.max_size)
  return max_size_;
}
inline void Channel::set_max_size(::google::protobuf::uint32 value) {
  set_has_max_size();
  max_size_ = value;
  // @@protoc_insertion_point(field_set:chaos.Channel.max_size)
}

// optional uint64 created_at = 5;
inline bool Channel::has_created_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Channel::set_has_created_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Channel::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Channel::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 Channel::created_at() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.created_at)
  return created_at_;
}
inline void Channel::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Channel.created_at)
}

// optional uint64 updated_at = 6;
inline bool Channel::has_updated_at() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Channel::set_has_updated_at() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Channel::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Channel::clear_updated_at() {
  updated_at_ = GOOGLE_ULONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::uint64 Channel::updated_at() const {
  // @@protoc_insertion_point(field_get:chaos.Channel.updated_at)
  return updated_at_;
}
inline void Channel::set_updated_at(::google::protobuf::uint64 value) {
  set_has_updated_at();
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:chaos.Channel.updated_at)
}

// repeated .chaos.Channel.Type types = 7;
inline int Channel::types_size() const {
  return types_.size();
}
inline void Channel::clear_types() {
  types_.Clear();
}
inline ::chaos::Channel_Type Channel::types(int index) const {
  // @@protoc_insertion_point(field_get:chaos.Channel.types)
  return static_cast< ::chaos::Channel_Type >(types_.Get(index));
}
inline void Channel::set_types(int index, ::chaos::Channel_Type value) {
  assert(::chaos::Channel_Type_IsValid(value));
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:chaos.Channel.types)
}
inline void Channel::add_types(::chaos::Channel_Type value) {
  assert(::chaos::Channel_Type_IsValid(value));
  types_.Add(value);
  // @@protoc_insertion_point(field_add:chaos.Channel.types)
}
inline const ::google::protobuf::RepeatedField<int>&
Channel::types() const {
  // @@protoc_insertion_point(field_list:chaos.Channel.types)
  return types_;
}
inline ::google::protobuf::RepeatedField<int>*
Channel::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:chaos.Channel.types)
  return &types_;
}

// -------------------------------------------------------------------

// DisruptionProperty

// required string key = 1;
inline bool DisruptionProperty::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisruptionProperty::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisruptionProperty::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisruptionProperty::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DisruptionProperty::key() const {
  // @@protoc_insertion_point(field_get:chaos.DisruptionProperty.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.DisruptionProperty.key)
}
inline void DisruptionProperty::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.DisruptionProperty.key)
}
inline void DisruptionProperty::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.DisruptionProperty.key)
}
inline ::std::string* DisruptionProperty::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:chaos.DisruptionProperty.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisruptionProperty::release_key() {
  // @@protoc_insertion_point(field_release:chaos.DisruptionProperty.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chaos.DisruptionProperty.key)
}

// required string type = 2;
inline bool DisruptionProperty::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisruptionProperty::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisruptionProperty::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisruptionProperty::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DisruptionProperty::type() const {
  // @@protoc_insertion_point(field_get:chaos.DisruptionProperty.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.DisruptionProperty.type)
}
inline void DisruptionProperty::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.DisruptionProperty.type)
}
inline void DisruptionProperty::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.DisruptionProperty.type)
}
inline ::std::string* DisruptionProperty::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:chaos.DisruptionProperty.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisruptionProperty::release_type() {
  // @@protoc_insertion_point(field_release:chaos.DisruptionProperty.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:chaos.DisruptionProperty.type)
}

// required string value = 3;
inline bool DisruptionProperty::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisruptionProperty::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisruptionProperty::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisruptionProperty::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& DisruptionProperty::value() const {
  // @@protoc_insertion_point(field_get:chaos.DisruptionProperty.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.DisruptionProperty.value)
}
inline void DisruptionProperty::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.DisruptionProperty.value)
}
inline void DisruptionProperty::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.DisruptionProperty.value)
}
inline ::std::string* DisruptionProperty::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:chaos.DisruptionProperty.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisruptionProperty::release_value() {
  // @@protoc_insertion_point(field_release:chaos.DisruptionProperty.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisruptionProperty::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:chaos.DisruptionProperty.value)
}

// -------------------------------------------------------------------

// Meta

// required string key = 1;
inline bool Meta::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Meta::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Meta::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Meta::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Meta::key() const {
  // @@protoc_insertion_point(field_get:chaos.Meta.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meta::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Meta.key)
}
inline void Meta::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Meta.key)
}
inline void Meta::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Meta.key)
}
inline ::std::string* Meta::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:chaos.Meta.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Meta::release_key() {
  // @@protoc_insertion_point(field_release:chaos.Meta.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meta::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chaos.Meta.key)
}

// required string value = 2;
inline bool Meta::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Meta::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Meta::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Meta::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Meta::value() const {
  // @@protoc_insertion_point(field_get:chaos.Meta.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meta::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos.Meta.value)
}
inline void Meta::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos.Meta.value)
}
inline void Meta::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos.Meta.value)
}
inline ::std::string* Meta::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:chaos.Meta.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Meta::release_value() {
  // @@protoc_insertion_point(field_release:chaos.Meta.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Meta::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:chaos.Meta.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chaos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::chaos::PtObject_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chaos::PtObject_Type>() {
  return ::chaos::PtObject_Type_descriptor();
}
template <> struct is_proto_enum< ::chaos::Channel_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chaos::Channel_Type>() {
  return ::chaos::Channel_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chaos_2eproto__INCLUDED
